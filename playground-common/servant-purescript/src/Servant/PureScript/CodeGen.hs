{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE RecordWildCards #-}

module Servant.PureScript.CodeGen where

import Control.Lens hiding (List, op)
import qualified Data.Map as Map
import Data.Maybe (fromMaybe, maybeToList, listToMaybe)
import qualified Data.Set as Set
import Data.Text (Text, toUpper)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import Language.PureScript.Bridge (ImportLine (..), ImportLines, PSType, TypeInfo (..), importLineToText, mergeImportLines, renderText, typeInfoToDecl, typeModule, typeToDecode, typeToEncode, typesToImportLines, flattenTypeInfo)
import Language.PureScript.Bridge.PSTypes (psUnit)
import Servant.Foreign
import Servant.PureScript.Internal
import Text.PrettyPrint.Mainland
import Data.Functor (($>))
import Network.HTTP.Types

typeInfoToText :: PSType -> Text
typeInfoToText = renderText . typeInfoToDecl

genModule :: Settings -> [Req PSType] -> Doc
genModule settings@Settings{..} reqs =
  let apiImports = reqsToImportLines settings reqs
      imports = mergeImportLines _standardImports apiImports
   in docIntercalate
        (line <> line)
        [ genModuleHeader _apiModuleName imports,
          docIntercalate
            (line <> line)
            (map (genFunction settings) reqs)
        ]

genModuleHeader :: Text -> ImportLines -> Doc
genModuleHeader moduleName imports =
  let importLines =
        map (strictText . renderText . importLineToText)
          . Map.elems
          . Map.filter (\i -> exclude "Prelude" i && exclude "Prim" i)
          $ imports
   in "-- File auto generated by servant-purescript! --"
        </> "module" <+> strictText moduleName <+> "where" <> line
        </> "import Prelude" <> line
        </> docIntercalate line importLines
        </> "import Affjax.RequestBody (json) as Request"
        </> "import Data.Argonaut.Decode.Aeson as D"
        </> "import Data.Argonaut.Encode.Aeson as E"
        </> "import Data.String.NonEmpty as NES"
  where
    exclude m = (/= m) . importModule

reqParams
  :: Settings
  -> Req PSType
  -> ([Arg PSType], Maybe PSType, [Segment PSType], [QueryArg PSType], Maybe PSType)
reqParams Settings{..} req =
  let notGlobalHeader = (`Set.notMember` _globalHeaders) . unPathSegment . _argName
      notGlobalQueryParam =
        (`Set.notMember` _globalQueryParams) . unPathSegment . _argName . _queryArgName
      headers = req ^.. reqHeaders . traversed . _HeaderArg . filtered notGlobalHeader
      body = req ^.. reqBody . _Just
      pathSegments = req ^.. reqUrl . path . traversed
      queryString = req ^.. reqUrl . queryStr . traversed . filtered notGlobalQueryParam
      returnType = req ^. reqReturnType
   in (headers, listToMaybe body, pathSegments, queryString, returnType)

genFunction :: Settings -> Req PSType -> Doc
genFunction settings req =
  let fnName = req ^. reqFuncName . jsCamelCaseL
      method = req ^. reqMethod
      (headers, body, pathSegments, queryString, returnType) = reqParams settings req
      args = pathSegments ^.. traversed . to unSegment . _Cap
      pTypes = map _argType headers
        <> maybeToList body
        <> map _argType args
        <> map (_argType . _queryArgName) queryString
      pNames = map (unPathSegment . _argName) headers
        <> maybeToList (body $> "reqBody")
        <> map (unPathSegment . _argName) args
        <> map (unPathSegment . _argName . _queryArgName) queryString
      constraints =
        [ mkPsType "MonadAjax" [psJsonDecodeError, psJson, mkPsType "e" [], mkPsType "m" []] ]
      signature = genSignature fnName ["e", "m"] constraints pTypes returnType
      fbody = hang 2
        $ genFnHead fnName pNames </> genFnBody method headers body pathSegments queryString returnType
   in signature </> fbody

genSignature :: Text -> [Text] -> [PSType] -> [PSType] -> Maybe PSType -> Doc
genSignature fnName variables constraints params mRet =
  hang 2 $
    strictText fnName <+> "::"
      <> ( if null variables
             then mempty
             else line <> "forall" <+> docIntercalate space (strictText <$> variables) <> "."
         )
      <> ( if null constraints
             then mempty
             else
               line
                 <> docIntercalate
                   (" =>" <> line)
                   (map (strictText . typeInfoToText) constraints)
                 <+> "=>"
         )
      </> docIntercalate (" ->" <> line) (strictText . typeInfoToText <$> (params <> [retType]))
  where
    retType = mkPsType
      "ExceptT"
      [mkPsType "e" [], mkPsType "m" [], fromMaybe psUnit mRet]

genFnHead :: Text -> [Text] -> Doc
genFnHead fnName params = fName <+> align (docIntercalate softline docParams <+> "=")
  where
    docParams = map psVar params
    fName = strictText fnName

genFnBody :: Method -> [Arg PSType] -> Maybe PSType -> [Segment PSType] -> [QueryArg PSType] -> Maybe PSType -> Doc
genFnBody method headers body args queryString returnType = docIntercalate line $ hang 2 <$>
  [ strictText "request req"
  , strictText "where"
  , strictText "req = { method, uri, headers, content, encode, decode }"
  , strictText "method = Left" <+> methodDoc
  , strictText "uri = RelativeRef relativePart query Nothing"
  , strictText "headers = catMaybes" </> niceList headersDoc
  , strictText case body of
      Nothing -> "content = Nothing"
      Just _ -> "content = Just reqBody"
  , strictText "encode = E.encode encoder"
  , strictText "decode = D.decode decoder"
  , strictText "encoder =" <+> encoder
  , strictText "decoder =" <+> decoder
  , strictText "relativePart = RelativePartNoAuth $ Just" </> niceList segments
  , strictText "query =" <+> query
  ]
  where
    methodDoc = method ^. to T.decodeUtf8 . to toUpper . to strictText
    headersDoc = header <$> headers
    header arg = docIntercalate space
      [ strictText "RequestHeader"
      , dquotes $ strictText $ unPathSegment $ arg ^. argName
      , strictText "<<< toHeader <$>"
      , psVar $ unPathSegment $ arg ^. argName
      ]
    encoder = case body of
      Nothing -> strictText "E.null"
      Just t ->
        docIntercalate line (fmap strictText $ T.lines $ renderText $ typeToEncode t)
    decoder = case returnType of
      Nothing -> strictText "D.null"
      Just t ->
        docIntercalate line (fmap strictText $ T.lines $ renderText $ typeToDecode t)
    segments = segment . unSegment <$> args
    segment (Static (PathSegment seg)) = dquotes $ strictText seg
    segment (Cap arg) = "toPathSegment" <+> arg ^. argName . to unPathSegment . to psVar
    query = case queryString of
      [] -> strictText "Nothing"
      q -> strictText "Just $ fold" </> niceList (queryArg <$> q)
    queryArg arg = queryFn (arg ^. queryArgType) <+> dquotes name <+> name
      where
        name = arg ^. queryArgName . argName . to unPathSegment . to strictText
    queryFn Normal = "paramQueryPairs"
    queryFn Flag = "flagQueryPairs"
    queryFn List = "paramListQueryPairs"

niceList :: [Doc] -> Doc
niceList docs= lbracket <+> docIntercalate (line <> comma <> space) docs </> rbracket

unMaybe :: PSType -> PSType
unMaybe (TypeInfo "purescript-maybe" "Data.Maybe" "Maybe" [a]) = a
unMaybe a = a

-----------

reqsToImportLines :: Settings -> [Req PSType] -> ImportLines
reqsToImportLines settings =
  typesToImportLines
    . Set.fromList
    . filter (("Prim" /=) . view typeModule)
    . concatMap flattenTypeInfo
    . concatMap (reqToPSTypes settings)

reqToPSTypes :: Settings -> Req PSType -> [PSType]
reqToPSTypes settings req =
  let (headers, body, pathSegments, queryString, returnType) = reqParams settings req
      args = pathSegments ^.. traversed . to unSegment . _Cap
  in map _argType headers
      <> maybeToList body
      <> map _argType args
      <> map (_argType . _queryArgName) queryString
      <> maybeToList returnType

mkPsType :: Text -> [PSType] -> PSType
mkPsType = TypeInfo "" ""

mkPsMaybe :: PSType -> PSType
mkPsMaybe = mkPsType "Maybe" . pure

psJsonDecodeError :: PSType
psJsonDecodeError = mkPsType "JsonDecodeError" []

psJson :: PSType
psJson = mkPsType "Json" []

docIntercalate :: Doc -> [Doc] -> Doc
docIntercalate i = mconcat . punctuate i

textURLEncode :: Bool -> Text -> Text
textURLEncode spaceIsPlus = T.decodeUtf8 . urlEncode spaceIsPlus . T.encodeUtf8

-- | Little helper for generating valid variable names
psVar :: Text -> Doc
psVar = strictText . toPSVarName
