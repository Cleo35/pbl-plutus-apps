{-# LANGUAGE BlockArguments #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}

module Servant.PureScript.CodeGen where

import Control.Lens hiding (List, op)
import qualified Data.Map as Map
import Data.Maybe (fromMaybe, mapMaybe, maybeToList)
import Data.Set (Set)
import qualified Data.Set as Set
import Data.Text (Text, toUpper)
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import Language.PureScript.Bridge (ImportLine (..), ImportLines, PSType, TypeInfo (..), importLineToText, mergeImportLines, renderText, typeInfoToDecl, typeModule, typeToDecode, typeToEncode, typesToImportLines, flattenTypeInfo)
import Language.PureScript.Bridge.PSTypes (psUnit)
import Network.HTTP.Types.URI (urlEncode)
import Servant.Foreign
import Servant.PureScript.Internal
import Text.PrettyPrint.Mainland
import Data.Proxy (Proxy(..))

typeInfoToText :: PSType -> Text
typeInfoToText = renderText . typeInfoToDecl

genModule :: forall bridge. HasBridge bridge => Settings bridge -> [Req PSType] -> Doc
genModule opts reqs =
  let gParams = opts
        ^. globalParams
        . to (Set.map $ over pType $ languageBridge $ Proxy @bridge)
      apiImports = reqsToImportLines reqs
      imports = mergeImportLines (_standardImports opts) apiImports
   in docIntercalate
        (line <> line)
        [ genModuleHeader (_apiModuleName opts) imports,
          docIntercalate (line <> line) (map (genFunction gParams) reqs)
        ]

genModuleHeader :: Text -> ImportLines -> Doc
genModuleHeader moduleName imports =
  let importLines =
        map (strictText . renderText . importLineToText)
          . Map.elems
          . Map.filter (\i -> exclude "Prelude" i && exclude "Prim" i)
          $ imports
   in "-- File auto generated by servant-purescript! --"
        </> "module" <+> strictText moduleName <+> "where" <> line
        </> "import Prelude" <> line
        </> docIntercalate line importLines
        </> "import Affjax.RequestBody (json) as Request"
        </> "import Affjax.ResponseFormat (json) as Response"
        </> "import Data.Argonaut.Decode.Aeson as D"
        </> "import Data.Argonaut.Encode.Aeson as E"
        </> "import Data.String.NonEmpty as NES"
        </> "import URI.Extra.QueryPairs as QP"
        </> "import URI.Host as Host"
  where
    exclude m = (/= m) . importModule

genFunction :: Set PSParam -> Req PSType -> Doc
genFunction gParams req =
  let fnName = req ^. reqFuncName . jsCamelCaseL
      allParamsList = reqToParams req
      -- Use list not set, as we don't want to change order of parameters
      params = filter (not . flip Set.member gParams) allParamsList
      pTypes = map _pType params
      pNames = map _pName params
      constraints = [ mkPsType "MonadAjax" [mkPsType "m" []] ]
      signature = genSignature fnName ["m"] constraints pTypes (req ^. reqReturnType)
      body = indent 2 $ genFnHead fnName pNames </> genFnBody req
   in signature </> body

genSignature :: Text -> [Text] -> [PSType] -> [PSType] -> Maybe PSType -> Doc
genSignature fnName variables constraints params mRet =
  hang 2 $
    strictText fnName <+> "::"
      <> ( if null variables
             then mempty
             else line <> "forall" <+> docIntercalate space (strictText <$> variables) <> "."
         )
      <> ( if null constraints
             then mempty
             else
               line
                 <> docIntercalate
                   (" =>" <> line)
                   (map (strictText . typeInfoToText) constraints)
                 <+> "=>"
         )
      </> docIntercalate (" ->" <> line) (strictText . typeInfoToText <$> (params <> [retType]))
  where
    retType =
      mkPsType
        "ResponseT"
        [psJson, mkPsType "m" [], psJsonDecodeError, fromMaybe psUnit mRet]

genFnHead :: Text -> [Text] -> Doc
genFnHead fnName params = fName <+> align (docIntercalate softline docParams <+> "=")
  where
    docParams = map psVar params
    fName = strictText fnName

genFnBody :: Req PSType -> Doc
genFnBody req = docIntercalate line
  [ strictText "request req"
  , strictText "where"
  , strictText "req = { method, uri, uriPrintOptions, headers, content, encode, decode, responseFormat }"
  , strictText "method = Left" <+> (req ^. reqMethod . to T.decodeUtf8 . to toUpper . to strictText)
  , strictText "uri = RelativeRef relativePart query Nothing"
  , strictText "uriPrintOptions = { printUserInfo, printHosts, printPath, printRelPath, printQuery, printFragment }"
  , indent 2 $ strictText "headers = catMaybes" </> list (genHeaders req)
  , strictText case req ^. reqBody of
      Nothing -> "content = Nothing"
      Just _ -> "content = Just reqBody"
  , strictText "encode = Request.json <<< E.encode encoder"
  , case req ^. reqBody of
      Nothing -> strictText "encoder = E.value"
      Just body ->
        indent 2
          ( strictText "encoder = " <+> docIntercalate
              line
              (fmap strictText $ T.lines $ renderText $ typeToEncode body)
          )
  , case req ^. reqReturnType of
      Nothing -> strictText "decoder = D.decode D.null"
      Just retType ->
        indent 2
          ( strictText "decoder = " <+> docIntercalate
              line
              (fmap strictText $ T.lines $ renderText $ typeToDecode retType)
          )
  , strictText "responseFormat = Response.json"
  , strictText "relativePart = RelativePartNoAuth $ Just $ PathAbsolute $ Tuple <$> segmentNZ <*> pure segments"
  , strictText "query =" <+> genQuery req
  , strictText "responseFormat = Response.json"
  , strictText "printUserInfo = identity"
  , strictText "printHosts = Host.print"
  , strictText "printPath = identity"
  , strictText "printRelPath = Left"
  , strictText "printQuery = QP.print identity identity <<< queryPairs"
  , strictText "query =" <+> genQueryPairs req
  , strictText "printFragment = absurd"
  , strictText "segmentNZ =" <+> genSegmentNZ req
  , strictText "segments =" <+> genSegments req
  ]

genHeaders :: Req PSType -> [Doc]
genHeaders = error "not implemented"

genQuery :: Req PSType -> Doc
genQuery = error "not implemented"

genQueryPairs :: Req PSType -> Doc
genQueryPairs = error "not implemented"

genSegmentNZ :: Req PSType -> Doc
genSegmentNZ = error "not implemented"

genSegments :: Req PSType -> Doc
genSegments = error "not implemented"


-----------

reqsToImportLines :: [Req PSType] -> ImportLines
reqsToImportLines =
  typesToImportLines
    . Set.fromList
    . filter (("Prim" /=) . view typeModule)
    . concatMap flattenTypeInfo
    . concatMap reqToPSTypes

reqToPSTypes :: Req PSType -> [PSType]
reqToPSTypes req = map _pType (reqToParams req) ++ maybeToList (req ^. reqReturnType)

-- | Extract all function parameters from a given Req.
reqToParams :: Req PSType -> [Param PSType]
reqToParams req =
  fmap headerArgToParam (req ^. reqHeaders)
    ++ maybeToList (reqBodyToParam (req ^. reqBody))
    ++ urlToParams (req ^. reqUrl)

urlToParams :: Url PSType -> [Param PSType]
urlToParams url = mapMaybe (segmentToParam . unSegment) (url ^. path) ++ map queryArgToParam (url ^. queryStr)

segmentToParam :: SegmentType f -> Maybe (Param f)
segmentToParam (Static _) = Nothing
segmentToParam (Cap arg) =
  Just
    Param
      { _pType = arg ^. argType,
        _pName = arg ^. argName . to unPathSegment
      }

mkPsType :: Text -> [PSType] -> PSType
mkPsType = TypeInfo "" ""

mkPsMaybe :: PSType -> PSType
mkPsMaybe = mkPsType "Maybe" . pure

psJsonDecodeError :: PSType
psJsonDecodeError = mkPsType "JsonDecodeError" []

psJson :: PSType
psJson = mkPsType "Json" []

queryArgToParam :: QueryArg PSType -> Param PSType
queryArgToParam arg =
  Param
    { _pType = arg ^. queryArgName . argType,
      _pName = arg ^. queryArgName . argName . to unPathSegment
    }

headerArgToParam :: HeaderArg f -> Param f
headerArgToParam (HeaderArg arg) =
  Param
    { _pName = arg ^. argName . to unPathSegment,
      _pType = arg ^. argType
    }
headerArgToParam _ = error "We do not support ReplaceHeaderArg - as I have no idea what this is all about."

reqBodyToParam :: Maybe f -> Maybe (Param f)
reqBodyToParam = fmap (Param "reqBody")

docIntercalate :: Doc -> [Doc] -> Doc
docIntercalate i = mconcat . punctuate i

textURLEncode :: Bool -> Text -> Text
textURLEncode spaceIsPlus = T.decodeUtf8 . urlEncode spaceIsPlus . T.encodeUtf8

-- | Little helper for generating valid variable names
psVar :: Text -> Doc
psVar = strictText . toPSVarName
