{-# LANGUAGE CPP                   #-}
{-# LANGUAGE DataKinds             #-}
{-# LANGUAGE FlexibleInstances     #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE OverloadedStrings     #-}
{-# LANGUAGE RankNTypes            #-}
{-# LANGUAGE TypeApplications #-}

module Main where

import qualified Data.Map                                   as Map
import           Data.Monoid                                ((<>))
import           Data.Text                                  (Text)
import qualified Data.Text                                  as T
import           Language.PureScript.Bridge
import           Language.PureScript.Bridge.CodeGenSwitches
import           Language.PureScript.Bridge.TypeParameters
import           Test.Hspec                                 (Spec, describe,
                                                             hspec, it)
import           Test.Hspec.Expectations.Pretty
import           TestData
import           Text.PrettyPrint.Leijen.Text               (Doc, cat,
                                                             linebreak,
                                                             punctuate, vsep)
import RoundTrip.Spec (roundtripSpec)

main :: IO ()
main = hspec $ allTests *> roundtripSpec

allTests :: Spec
allTests = do
  describe "buildBridge without lens-code-gen" $ do
    let settings = getSettings noLenses
    it "tests generation of typeclasses for custom type Foo" $
      let recType =
            bridgeSumType
              (buildBridge defaultBridge)
              (genericShow . order $ mkSumType @Foo)
          recTypeText = sumTypeToDoc settings recType
          txt =
            T.unlines
              [ "data Foo"
              , "  = Foo"
              , "  | Bar Int"
              , "  | FooBar Int String"
              , ""
              , "instance showFoo :: Show Foo where"
              , "  show x = genericShow x"
              , ""
              , "derive instance eqFoo :: Eq Foo"
              , ""
              , "derive instance ordFoo :: Ord Foo"
              , ""
              , "derive instance genericFoo :: Generic Foo _"
              , ""
              , "--------------------------------------------------------------------------------"
              ]
       in recTypeText `shouldRender` txt
    it "tests generation of typeclasses for custom type Func" $
      let recType =
            bridgeSumType
              (buildBridge defaultBridge)
              (equal1 . functor . genericShow $ mkSumType @(Func A))
          recTypeText = sumTypeToDoc settings recType
          txt =
            T.unlines
              [ "data Func a"
              , "  = Func Int a"
              , ""
              , "derive instance eq1Func :: Eq1 Func"
              , ""
              , "derive instance functorFunc :: Functor Func"
              , ""
              , "instance showFunc :: (Show a) => Show (Func a) where"
              , "  show x = genericShow x"
              , ""
              , "derive instance genericFunc :: Generic (Func a) _"
              , ""
              , "--------------------------------------------------------------------------------"
              ]
       in recTypeText `shouldRender` txt
    it "tests the generation of a whole (dummy) module" $
      let advanced' =
            bridgeSumType
              (buildBridge defaultBridge)
              (mkSumType @(Bar A B M1 C))
          modules = sumTypeToModule advanced'
          m = head . map (moduleToText settings) . Map.elems $ modules
          txt =
            T.unlines
              [ "-- File auto generated by purescript-bridge! --"
              , "module TestData where"
              , ""
              , "import Prelude"
              , "import Data.Either (Either)"
              , "import Data.Generic.Rep (class Generic)"
              , "import Data.Maybe (Maybe, Maybe(..))"
              , ""
              , "data Bar a b m c"
              , "  = Bar1 (Maybe a)"
              , "  | Bar2 (Either a b)"
              , "  | Bar3 a"
              , "  | Bar4"
              , "      { myMonadicResult :: (m b)"
              , "      }"
              , ""
              , "derive instance genericBar :: Generic (Bar a b m c) _"
              , ""
              , "--------------------------------------------------------------------------------"
              ]
       in m `shouldBe` txt
    it "tests generation of newtypes for record data type" $
      let recType' =
            bridgeSumType
              (buildBridge defaultBridge)
              (mkSumType @(SingleRecord A B))
          recTypeText = sumTypeToDoc settings recType'
          txt =
            T.unlines
              [ "newtype SingleRecord a b"
              , "  = SingleRecord"
              , "      { _a :: a"
              , "      , _b :: b"
              , "      , c :: String"
              , "      }"
              , ""
              , "derive instance genericSingleRecord :: Generic (SingleRecord a b) _"
              , ""
              , "derive instance newtypeSingleRecord :: Newtype (SingleRecord a b) _"
              , ""
              , "--------------------------------------------------------------------------------"
              ]
       in recTypeText `shouldRender` txt
    it "tests generation of newtypes for haskell newtype" $
      let recType' =
            bridgeSumType
              (buildBridge defaultBridge)
              (mkSumType @SomeNewtype)
          recTypeText = sumTypeToDoc settings recType'
          txt =
            T.unlines
              [ "newtype SomeNewtype"
              , "  = SomeNewtype Int"
              , ""
              , "derive instance genericSomeNewtype :: Generic SomeNewtype _"
              , ""
              , "derive instance newtypeSomeNewtype :: Newtype SomeNewtype _"
              , ""
              , "--------------------------------------------------------------------------------"
              ]
       in recTypeText `shouldRender` txt
    it "tests generation of newtypes for haskell data type with one argument" $
      let recType' =
            bridgeSumType
              (buildBridge defaultBridge)
              (mkSumType @SingleValueConstr)
          recTypeText = sumTypeToDoc settings recType'
          txt =
            T.unlines
              [ "newtype SingleValueConstr"
              , "  = SingleValueConstr Int"
              , ""
              , "derive instance genericSingleValueConstr :: Generic SingleValueConstr _"
              , ""
              , "derive instance newtypeSingleValueConstr :: Newtype SingleValueConstr _"
              , ""
              , "--------------------------------------------------------------------------------"
              ]
       in recTypeText `shouldRender` txt
    it
      "tests generation for haskell data type with one constructor, two arguments" $
      let recType' =
            bridgeSumType
              (buildBridge defaultBridge)
              (mkSumType @SingleProduct)
          recTypeText = sumTypeToDoc settings recType'
          txt =
            T.unlines
              [ "data SingleProduct"
              , "  = SingleProduct String Int"
              , ""
              , "derive instance genericSingleProduct :: Generic SingleProduct _"
              , ""
              , "--------------------------------------------------------------------------------"
              ]
       in recTypeText `shouldRender` txt
    it "tests generation Eq instances for polymorphic types" $
      let recType' =
            bridgeSumType
              (buildBridge defaultBridge)
              (equal $ mkSumType @(SingleRecord A B))
          recTypeText = sumTypeToDoc settings recType'
          txt =
            T.unlines
              [ "newtype SingleRecord a b"
              , "  = SingleRecord"
              , "      { _a :: a"
              , "      , _b :: b"
              , "      , c :: String"
              , "      }"
              , ""
              , "derive instance eqSingleRecord :: (Eq a, Eq b) => Eq (SingleRecord a b)"
              , ""
              , "derive instance genericSingleRecord :: Generic (SingleRecord a b) _"
              , ""
              , "derive instance newtypeSingleRecord :: Newtype (SingleRecord a b) _"
              , ""
              , "--------------------------------------------------------------------------------"
              ]
       in recTypeText `shouldRender` txt
    it "tests generation of Ord instances for polymorphic types" $
      let recType' =
            bridgeSumType
              (buildBridge defaultBridge)
              (order $ mkSumType @(SingleRecord A B))
          recTypeText = sumTypeToDoc settings recType'
          txt =
            T.unlines
              [ "newtype SingleRecord a b"
              , "  = SingleRecord"
              , "      { _a :: a"
              , "      , _b :: b"
              , "      , c :: String"
              , "      }"
              , ""
              , "derive instance eqSingleRecord :: (Eq a, Eq b) => Eq (SingleRecord a b)"
              , ""
              , "derive instance ordSingleRecord :: (Ord a, Ord b) => Ord (SingleRecord a b)"
              , ""
              , "derive instance genericSingleRecord :: Generic (SingleRecord a b) _"
              , ""
              , "derive instance newtypeSingleRecord :: Newtype (SingleRecord a b) _"
              , ""
              , "--------------------------------------------------------------------------------"
              ]
       in recTypeText `shouldRender` txt

shouldRender :: Doc -> Text -> Expectation
shouldRender actual expected = renderText actual `shouldBe` T.stripEnd expected
