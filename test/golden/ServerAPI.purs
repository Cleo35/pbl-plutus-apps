-- File auto generated by servant-purescript! --
module ServerAPI where

import Prelude

import Affjax (Error, Request, Response, defaultRequest, request)
import Affjax.RequestHeader (RequestHeader(..))
import Control.Monad.Error.Class (class MonadError, throwError)
import Control.Monad.Reader.Class (ask, class MonadAsk)
import Data.Argonaut.Core (Json, stringify)
import Data.Argonaut.Decode (JsonDecodeError, decodeJson)
import Data.Argonaut.Decode.Generic (genericDecodeJson)
import Data.Argonaut.Encode (encodeJson)
import Data.Argonaut.Encode.Generic (class EncodeRep, genericEncodeJson)
import Data.Array (fromFoldable, null)
import Data.Either (Either(..))
import Data.Generic.Rep (class Generic)
import Data.HTTP.Method (Method(..))
import Data.Maybe (Maybe, Maybe(..))
import Data.Newtype (unwrap)
import Data.String (joinWith)
import Effect.Aff.Class (class MonadAff, liftAff)
import ServerTypes (Hello, TestHeader)
import Affjax.RequestBody (json) as Request
import Affjax.ResponseFormat (json) as Response

class ToURLPiece a where
  toURLPiece :: a -> String

instance toURLPieceString :: ToURLPiece String where
  toURLPiece = identity
else instance toURLPieceBoolean :: ToURLPiece Boolean where
  toURLPiece = show
else instance toURLPieceInt :: ToURLPiece Int where
  toURLPiece = show
else instance toURLPieceNumber :: ToURLPiece Number where
  toURLPiece = show
else instance toURLPieceChar :: ToURLPiece Char where
  toURLPiece = show
else instance toURLPieceArray :: (ToURLPiece a) => ToURLPiece (Array a) where
  toURLPiece = stringify <<< encodeJson <<< map toURLPiece
else instance toURLPieceMaybe :: (ToURLPiece a) => ToURLPiece (Maybe a) where
  toURLPiece = stringify <<< encodeJson <<< map toURLPiece
else instance toURLPieceAny :: (Generic a rep, EncodeRep rep) => ToURLPiece a where
  toURLPiece = stringify <<< genericEncodeJson

type AjaxError
  = { request :: Request Json
    , description :: ErrorDescription
    }

data ErrorDescription
  = UnexpectedHTTPStatus (Response Json)
  | DecodingError JsonDecodeError
  | ConnectingError Error

type SPSettings_
  = { testHeader :: Maybe TestHeader
    , baseURL :: String
    }

getHello ::
  forall m.
  MonadAsk SPSettings_ m =>
  MonadError AjaxError m =>
  MonadAff m =>
  Hello ->
  Boolean ->
  Maybe Hello ->
  Array Hello ->
  m Hello
getHello reqBody myFlag myParam myParams = do
  spSettings <- ask
  let testHeader = spSettings.testHeader
  let baseURL = spSettings.baseURL
  let httpMethod = Left GET
  let
      encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
      encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
      queryArgs :: Array String
      queryArgs =
        []
          <> [ encodeQueryItem "myFlag" myFlag ]
          <> fromFoldable (encodeQueryItem "myParam" <$> myParam)
          <> ( encodeQueryItem "myParams" <$> myParams )
  let queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
      reqURL =
        baseURL
          <> "hello"
          <> queryString
  let
      reqHeaders =
        [ RequestHeader "TestHeader" $ toURLPiece testHeader
        ]
  let
      affReq =
        defaultRequest
          { method = httpMethod
          , url = reqURL
          , headers = defaultRequest.headers <> reqHeaders
          , responseFormat = Response.json
          , content = Just $ Request.json $ genericEncodeJson reqBody
          }
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299) $
    throwError $ { request: affReq, description: UnexpectedHTTPStatus response }
  case genericDecodeJson response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body

getTestHeader ::
  forall m.
  MonadAsk SPSettings_ m =>
  MonadError AjaxError m =>
  MonadAff m =>
  m TestHeader
getTestHeader = do
  spSettings <- ask
  let testHeader = spSettings.testHeader
  let baseURL = spSettings.baseURL
  let httpMethod = Left GET
  let
      encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
      encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
      queryArgs :: Array String
      queryArgs =
        []
  let queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
      reqURL =
        baseURL
          <> "testHeader"
          <> queryString
  let
      reqHeaders =
        [ RequestHeader "TestHeader" $ toURLPiece testHeader
        ]
  let
      affReq =
        defaultRequest
          { method = httpMethod
          , url = reqURL
          , headers = defaultRequest.headers <> reqHeaders
          , responseFormat = Response.json
          }
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299) $
    throwError $ { request: affReq, description: UnexpectedHTTPStatus response }
  case genericDecodeJson response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body

getBy ::
  forall m.
  MonadAsk SPSettings_ m =>
  MonadError AjaxError m =>
  MonadAff m =>
  m Int
getBy = do
  spSettings <- ask
  let testHeader = spSettings.testHeader
  let baseURL = spSettings.baseURL
  let httpMethod = Left GET
  let
      encodeQueryItem :: forall a. ToURLPiece a => String -> a -> String
      encodeQueryItem name val = name <> "=" <> toURLPiece val
  let
      queryArgs :: Array String
      queryArgs =
        []
  let queryString = if null queryArgs then "" else "?" <> (joinWith "&" queryArgs)
  let
      reqURL =
        baseURL
          <> "by"
          <> queryString
  let
      reqHeaders =
        [ RequestHeader "TestHeader" $ toURLPiece testHeader
        ]
  let
      affReq =
        defaultRequest
          { method = httpMethod
          , url = reqURL
          , headers = defaultRequest.headers <> reqHeaders
          , responseFormat = Response.json
          }
  result <- liftAff $ request affReq
  response <- case result of
    Left err -> throwError $ { request: affReq, description: ConnectingError err }
    Right r -> pure r
  when (unwrap response.status < 200 || unwrap response.status >= 299) $
    throwError $ { request: affReq, description: UnexpectedHTTPStatus response }
  case decodeJson response.body of
    Left err -> throwError $ { request: affReq, description: DecodingError err }
    Right body -> pure body
